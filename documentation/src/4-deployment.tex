\chapter{Deployment}
This chapter provides an implementation-ready guide for deploying the "Gift List" application in a self-hosted environment using a Ugreen NAS via its native Docker application. The strategy focuses on high reliability, security of personal NAS files, and automated CI/CD maintenance via GitHub Actions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Infrastructure Overview}
The application is deployed as a suite of Docker containers managed by Docker Compose. This ensures environment consistency and simplifies updates.

\begin{itemize}
    \item \textbf{Host OS}: Ugreen NAS OS (Linux-based) with Docker App.
    \item \textbf{Runtime}: Docker Engine + Docker Compose V2.
    \item \textbf{Storage}: Persistent data is stored in Docker Volumes. For security, only specific application data folders are mapped; the rest of the NAS filesystem is completely isolated from the containers.
    \item \textbf{Persistency}: The PostgreSQL data is written directly into the \texttt{NAS\_DATABASE\_DATA} Docker volume. This ensures that even if the container is destroyed or restarted, the data persists, and rebuilding the application does not cause data loss.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Containerization Strategy}
The system consists of several specialized services orchestrated via \texttt{docker-compose.yml}.

\subsection{Service Definition}
\begin{enumerate}
    \item \textbf{Frontend}: A production-ready Nginx container serving the React static files.
    \item \textbf{API (Backend)}: The Node.js Express application.
    \item \textbf{Database (PostgreSQL)}: The primary data store.
    \item \textbf{Cloudflare Tunnel}: Handles secure external access without port forwarding.
    \item \textbf{Backup Agent}: A lightweight container that performs scheduled database dumps.
\end{enumerate}

\subsection{Database Schema Initialization}
To ensure the database schema is up-to-date and directly applied to the empty database on the NAS before the application starts, the API service is configured to synchronize on startup.
\begin{itemize}
    \item \textbf{Entrypoint Command}: The Docker definition for the \texttt{api} service overrides the default command to execute \texttt{npx prisma db push} before starting the server. This guarantees that the table structure correctly matches the codebase upon the first launch and skips the need to export local migration files to the container. The command safely ignores non-destructive changes, retaining all data during re-deployments.
\end{itemize}

\subsection{Nginx Configuration for SPA}
Since the Frontend is a Single Page Application (SPA) using React Router, the Nginx server must be configured to handle client-side routing correctly.
\begin{itemize}
  \item \textbf{Fallback Strategy}: The Nginx configuration file (\texttt{nginx.conf}) must include a \texttt{try\_files} directive. This ensures that any request for a non-existent file (e.g., \texttt{/lists/my-list}) is internally redirected to \texttt{index.html}, allowing React Router to handle the URL. Additionally, the configuration includes a proxy block to route \texttt{/api/} requests to the backend service.
    \begin{verbatim}
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://api:3000;
        proxy_set_header Host $host;
        # ... other headers
    }
    \end{verbatim}
\end{itemize}

\subsection{Docker Compose Configuration (Implementation Ready)}
\begin{verbatim}
services:
  frontend:
    image: ghcr.io/your_github_username/gift-list-frontend:main
    restart: always
    environment:
      - VITE_API_BASE_URL=https://giftlist.yourdomain.com/api/v1
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  api:
    image: ghcr.io/your_github_username/gift-list-backend:main
    restart: always
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/giftlist
      - PORT=3000
      - JWT_SECRET=${JWT_SECRET}
      - CORS_ORIGIN=https://giftlist.yourdomain.com
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_PORT=${SMTP_PORT}
      - SMTP_USER=${SMTP_USER}
      - SMTP_PASS=${SMTP_PASS}
    depends_on:
      - db
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  db:
    image: postgres:17-alpine
    restart: always
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=giftlist
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  tunnel:
    image: cloudflare/cloudflared:latest
    restart: always
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=your_cloudflare_tunnel_token
    depends_on:
      - frontend
      - api

  watchtower:
    image: containrrr/watchtower
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command: --interval 300 frontend api
    # This automatically updates the 'frontend' and 'api' images when a new version is pushed to the registry.

  db-backup:
    image: prodrigestivill/postgres-backup-local
    restart: always
    volumes:
      - pgdata:/var/lib/postgresql/data:ro
      - ./backups:/backups
    environment:
      - POSTGRES_HOST=db
      - SCHEDULE=@daily
      - BACKUP_KEEP_DAYS=7

volumes:
  pgdata:
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Networking and Security}
To expose the application securely without opening ports on the home router, we utilize **Cloudflare Tunnels**.

\subsection{Cloudflare Tunnel Integration}
A Cloudflare Tunnel (\texttt{cloudflared}) creates a secure, encrypted connection between the Ugreen NAS and the Cloudflare edge.
\begin{itemize}
    \item \textbf{Traffic Routing}: The tunnel is configured via the Cloudflare Dashboard to route traffic:
    \begin{itemize}
        \item \texttt{giftlist.yourdomain.com} $\rightarrow$ \texttt{http://frontend:80}
        \item \texttt{giftlist.yourdomain.com/api} $\rightarrow$ \texttt{http://api:3000/api}
    \end{itemize}
    \item \textbf{No Port Forwarding}: The router remains closed to incoming traffic.
    \item \textbf{Automatic HTTPS}: Cloudflare manages SSL/TLS certificates automatically.
\end{itemize}

\subsection{Security Hardening}
\begin{itemize}
    \item \textbf{Internal Networking}: Only the Frontend and API services are indirectly exposed via the tunnel. The Database is only accessible within the internal Docker network.
    \item \textbf{Log Rotation}: Configured globally in the Compose file to prevent the SD card from filling up (max 3 files of 10MB each per service).
    \item \textbf{Environment Secrets}: For simplicity and maximum compatibility with NAS Graphic Interfaces (which sometimes ignore hidden files like \texttt{.env}), sensitive parameters (DB passwords, Cloudflare tokens) are bundled directly inside the \texttt{docker-compose.yml} configuration in a single source of truth.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reliability and Backup Strategy}
Reliability is achieved through automated recovery and off-site data preservation.

\subsection{Auto-Restart}
Docker's \texttt{restart: always} policy ensures that if a service crashes or the NAS reboots, the entire stack restarts automatically.

\subsection{Automated Backups}
The \texttt{db-backup} service performs a daily compressed dump at 00:00. The host machine is configured with a cron job to synchronize the \texttt{./backups} folder to an off-site location (e.g., encrypted S3 bucket).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CI/CD Pipeline (GitHub Actions)}
To decouple the build process from the NAS, a CI/CD pipeline is implemented using GitHub Actions.
\begin{itemize}
    \item \textbf{Build on Push}: Every push to the \texttt{main} branch triggers a workflow that builds the Docker images for the Frontend and API.
    \item \textbf{Push to Registry}: The built images are automatically pushed to the GitHub Container Registry (GHCR).
    \item \textbf{Automated Pull}: The \texttt{watchtower} service on the NAS periodically checks GHCR for new images and automatically restarts the containers with the latest version without manual intervention.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architectural Decision Records}
\subsection{Docker Compose vs. Kubernetes (K3s)}
Docker Compose was selected for its native integration with the Ugreen NAS Docker app and its minimal resource footprint. This ensures all NAS resources are preserved for file storage and the application itself, unlike K3s which requires significant resources for its control plane.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Monitoring and Logs}
\begin{itemize}
    \item \textbf{Docker Logs}: \texttt{docker compose logs -f [service\_name]} for real-time debugging.
    \item \textbf{Health Checks}: A simple heartbeat monitoring service (e.g., UptimeRobot) targets the public URL.
\end{itemize}
