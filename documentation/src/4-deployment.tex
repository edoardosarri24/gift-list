\chapter{Deployment}
This chapter provides an implementation-ready guide for deploying the "Gift List" application in a self-hosted environment using a Raspberry Pi 4 (4GB RAM). The strategy focuses on high reliability, security, and automated maintenance.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Infrastructure Overview}
The application is deployed as a suite of Docker containers managed by Docker Compose. This ensures environment consistency and simplifies updates.

\begin{itemize}
    \item \textbf{Host OS}: Raspberry Pi OS (64-bit) or any Debian-based distribution.
    \item \textbf{Runtime}: Docker Engine + Docker Compose V2.
    \item \textbf{Storage}: Persistent data is stored in Docker Volumes, which are mapped to the host's filesystem for easier backups.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Containerization Strategy}
The system consists of several specialized services orchestrated via \texttt{docker-compose.yml}.

\subsection{Service Definition}
\begin{enumerate}
    \item \textbf{Frontend}: A production-ready Nginx container serving the React static files.
    \item \textbf{API (Backend)}: The Node.js Express application.
    \item \textbf{Database (PostgreSQL)}: The primary data store.
    \item \textbf{Cloudflare Tunnel}: Handles secure external access without port forwarding.
    \item \textbf{Backup Agent}: A lightweight container that performs scheduled database dumps.
\end{enumerate}

\subsection{Database Migrations}
To ensure the database schema is up-to-date before the application starts, the API service is configured to run migrations on startup.
\begin{itemize}
    \item \textbf{Entrypoint Command}: The Docker definition for the \texttt{api} service overrides the default command to execute \texttt{npx prisma migrate deploy} before starting the server. This guarantees that all pending migrations are applied to the production database automatically.
\end{itemize}

\subsection{Nginx Configuration for SPA}
Since the Frontend is a Single Page Application (SPA) using React Router, the Nginx server must be configured to handle client-side routing correctly.
\begin{itemize}
    \item \textbf{Fallback Strategy}: The Nginx configuration file (\texttt{nginx.conf}) must include a \texttt{try\_files} directive. This ensures that any request for a non-existent file (e.g., \texttt{/lists/my-list}) is internally redirected to \texttt{index.html}, allowing React Router to handle the URL.
    \begin{verbatim}
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }
    \end{verbatim}
\end{itemize}

\subsection{Docker Compose Configuration (Implementation Ready)}
\begin{verbatim}
services:
  frontend:
    build: 
      context: ./apps/frontend
      dockerfile: Dockerfile
    restart: always
    environment:
      - VITE_API_BASE_URL=https://giftlist.yourdomain.com/api/v1
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  api:
    build: ./apps/backend
    restart: always
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/giftlist
      - PORT=3000
      - JWT_SECRET=${JWT_SECRET}
      - CORS_ORIGIN=https://giftlist.yourdomain.com
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_PORT=${SMTP_PORT}
      - SMTP_USER=${SMTP_USER}
      - SMTP_PASS=${SMTP_PASS}
    depends_on:
      - db
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  db:
    image: postgres:17-alpine
    restart: always
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=giftlist
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  tunnel:
    image: cloudflare/cloudflared:latest
    restart: always
    command: tunnel run --token ${CLOUDFLARE_TOKEN}
    depends_on:
      - frontend
      - api

  db-backup:
    image: prodrigestivill/postgres-backup-local
    restart: always
    volumes:
      - pgdata:/var/lib/postgresql/data:ro
      - ./backups:/backups
    environment:
      - POSTGRES_HOST=db
      - SCHEDULE=@daily
      - BACKUP_KEEP_DAYS=7

volumes:
  pgdata:
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Networking and Security}
To expose the application securely without opening ports on the home router, we utilize **Cloudflare Tunnels**.

\subsection{Cloudflare Tunnel Integration}
A Cloudflare Tunnel (\texttt{cloudflared}) creates a secure, encrypted connection between the Raspberry Pi and the Cloudflare edge.
\begin{itemize}
    \item \textbf{Traffic Routing}: The tunnel is configured via the Cloudflare Dashboard to route traffic:
    \begin{itemize}
        \item \texttt{giftlist.yourdomain.com} $\rightarrow$ \texttt{http://frontend:80}
        \item \texttt{giftlist.yourdomain.com/api} $\rightarrow$ \texttt{http://api:3000/api}
    \end{itemize}
    \item \textbf{No Port Forwarding}: The router remains closed to incoming traffic.
    \item \textbf{Automatic HTTPS}: Cloudflare manages SSL/TLS certificates automatically.
\end{itemize}

\subsection{Security Hardening}
\begin{itemize}
    \item \textbf{Internal Networking}: Only the Frontend and API services are indirectly exposed via the tunnel. The Database is only accessible within the internal Docker network.
    \item \textbf{Log Rotation}: Configured globally in the Compose file to prevent the SD card from filling up (max 3 files of 10MB each per service).
    \item \textbf{Environment Secrets}: Sensitive data (DB passwords, Cloudflare tokens) are managed via a \texttt{.env} file.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reliability and Backup Strategy}
Reliability is achieved through automated recovery and off-site data preservation.

\subsection{Auto-Restart}
Docker's \texttt{restart: always} policy ensures that if a service crashes or the Raspberry Pi reboots, the entire stack restarts automatically.

\subsection{Automated Backups}
The \texttt{db-backup} service performs a daily compressed dump at 00:00. The host machine is configured with a cron job to synchronize the \texttt{./backups} folder to an off-site location (e.g., encrypted S3 bucket).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architectural Decision Records}
\subsection{Docker Compose vs. Kubernetes (K3s)}
Docker Compose was selected for its minimal resource footprint (approx. 50MB RAM overhead), ensuring that the majority of the Raspberry Pi's 4GB RAM is available for PostgreSQL and the Node.js API, unlike K3s which requires significant resources for its control plane.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Monitoring and Logs}
\begin{itemize}
    \item \textbf{Docker Logs}: \texttt{docker compose logs -f [service\_name]} for real-time debugging.
    \item \textbf{Health Checks}: A simple heartbeat monitoring service (e.g., UptimeRobot) targets the public URL.
\end{itemize}
