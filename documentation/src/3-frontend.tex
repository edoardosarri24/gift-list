\chapter{Frontend}
This chapter details the architectural decisions and technical specifications for the client-side application of the "Gift List" project. The frontend serves as the primary interface for both Celebrants (to manage lists) and Guests (to view and claim gifts).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Technology Stack}
The frontend will be built as a Single Page Application (SPA) using the following core technologies:
\begin{itemize}
    \item Framework \\
        React (v19 or latest stable).
    \item Language \\
        TypeScript. To ensure type safety and align with the backend data models.
    \item Build Tool \\
        Vite. Chosen for its superior performance and rapid development cycle.
    \item Routing \\
        React Router (v7).
    \item API Client \\
        Axios. Used for its robust interceptor support, allowing centralized handling of JWT authentication and error responses.
    \item Form Management \& Validation \\
        React Hook Form combined with Zod for schema-based validation.
    \item Iconography \\
        Lucide React. A clean, consistent icon set with a small bundle footprint.
    \item State Management \\
    \begin{itemize}
        \item \textit{Server State:} TanStack Query (React Query). To handle data fetching, caching, and synchronization with the backend.
        \item \textit{Client State:} React Context API for global UI state (e.g., theme, user session).
    \end{itemize}
    \item Styling \\
        CSS Modules with Vanilla CSS.
    \item Internationalization \\
        \texttt{react-i18next}. To manage translations and user language preferences. The app is fully localized in Italian and English.
    \item Image Processing \\
        \texttt{react-easy-crop} for an interactive visual cropping experience, and \texttt{heic2any} to seamlessly convert Apple HEIC formats to standard JPEG before upload.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Form \& Validation Strategy}
To ensure a high-quality user experience and data integrity, form management follows a strict pattern:
\begin{itemize}
    \item Schema Sharing \\
        Validation schemas (Zod) are defined in a shared package at \texttt{packages/shared/validations} to be used by both the frontend forms and backend API controllers, ensuring a single source of truth.
    \item Error Feedback \\
        Validation errors are displayed in real-time as the user types, providing immediate corrective feedback.
    \item Submission Lifecycle \\
        Submit buttons transition to a "Loading" state during API calls, disabling further clicks to prevent duplicate submissions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Image Uploading and Processing}
A critical feature of the dashboard is the ability for celebrants to customize their lists with a representative image. To ensure a premium user experience and server compatibility, image processing is handled entirely client-side before transmission:
\begin{itemize}
    \item \textbf{Upload Methods}: Users can upload images via a native drag-and-drop file interface or by pasting an external image URL. 
    \item \textbf{HEIC Conversion}: Apple devices natively capture photos in \texttt{.heic} format. The frontend automatically intercepts these files and converts them to \texttt{.jpg} using \texttt{heic2any} directly in the browser, ensuring universal compatibility without backend overhead.
    \item \textbf{Interactive Cropping}: Uploaded or URL-imported images are loaded onto an interactive 1:1 circular canvas using \texttt{react-easy-crop}, allowing the user to precisely frame and zoom the picture.
    \item \textbf{Data Transmission}: The final cropped image is generated as an optimized JPEG base64 Data URL, which is sent securely to the backend payload.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{API Interaction}
Axios is configured as a singleton client with the following settings:
\begin{itemize}
    \item \textbf{Base URL}: Configured with the \texttt{/api/v1} prefix to ensure compatibility with versioned backend routes.
    \item \texttt{withCredentials: true} \\
        This is mandatory to allow the browser to send and receive the \texttt{guest\_session} cookie (for Guests) and the \texttt{refresh\_token} cookie (for Celebrants).
    \item Authentication Header \\
        An interceptor automatically attaches the \texttt{Authorization: Bearer <token>} header to all requests if a JWT is present.
    \item \textbf{Token Refresh Interceptor} \\
        A specialized interceptor catches \texttt{401 Unauthorized} errors. If the error is due to an expired Access Token, the client attempts a one-time refresh via the \texttt{POST /auth/refresh} endpoint. If successful, the original request is retried with the new token; otherwise, the user is logged out.
    \item \textbf{Global Error Interceptor} \\
        A response interceptor catches other specific status codes to trigger global notifications (Toasts).
        \begin{itemize}
            \item \textbf{Guest Session Handling}: If a Guest attempts to access a protected list route (e.g., \texttt{GET /lists/:slug}) and receives a \texttt{401 Unauthorized} or \texttt{403 Forbidden} error (indicating an invalid or missing session cookie), the interceptor automatically redirects the user to the access page (\texttt{/lists/:slug/access}) to re-enter their email.
        \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Internationalization (i18n)}
The application supports English and Italian using \texttt{react-i18next}.
\begin{itemize}
    \item \textbf{Detection}: The language is detected via the browser settings (\texttt{i18next-browser-languagedetector}).
    \item \textbf{Structure}: Translation strings are stored in JSON files within \texttt{/public/locales/{en|it}/common.json}.
    \item \textbf{Guest Preference}: When a Guest provides their email to access a list, their current language setting is sent to the backend to ensure notification emails are sent in the correct language.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Browser Compatibility}
To ensure a consistent and secure user experience, the application restricts access based on browser capabilities.

\subsection{Unsupported Browsers Policy}
The frontend application includes a strict check for browser compatibility during the initialization phase.
\begin{itemize}
    \item Detection Mechanism \\
        The application detects the user's browser version and capabilities (e.g., support for ES6+ features, CSS Grid, Flexbox) before rendering the main application logic.
    \item Handling Unsupported Environments \\
        If an unsupported browser or a legacy version is detected (e.g., Internet Explorer), the application will:
    \begin{enumerate}
        \item Halt Execution: React will not mount the root component to prevent runtime errors or visual artifacts.
        \item Display Error Message: A full-screen, user-friendly error message will be shown, informing the user that their browser is not supported and recommending an update to a modern browser (Chrome, Firefox, Safari, Edge).
    \end{enumerate}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architectural Decision Records}
A key requirement for this project is the future expansion into a native mobile application. This requirement significantly influenced the choice of the frontend framework.

\subsection{Why React?}
React was selected as the optimal choice for a "Web-First, Mobile-Second" strategy.
\begin{itemize}
    \item Web Performance \\
        The primary use case involves Guests accessing lists via shared links. React, combined with Vite, offers a lightweight bundle and fast "Time-to-Interactive", which is crucial for reducing bounce rates on mobile browsers.
    \item Code Reusability \\
        By using TypeScript, we can share data types and validation logic directly between the Backend (Node.js) and Frontend. Furthermore, the business logic encapsulated in Custom Hooks (e.g., \texttt{useClaimGift}) can be reused almost entirely in a future React Native application.
    \item Ecosystem \\
        The React ecosystem is vast, providing robust solutions for every requirement (forms, animations, accessibility) without the need to reinvent the wheel.
\end{itemize}

\subsection{Comparison with Alternatives}
We evaluated two major alternatives before selecting React.

\subsubsection{React vs. Flutter (Dart)}
Flutter is a powerful toolkit for building natively compiled applications, but it was deemed less suitable for this project:
\begin{itemize}
    \item Web "Heaviness" \\
        Flutter for Web renders the UI on a canvas, resulting in a large initial download size. For a Guest who simply needs to view a list and click a button, this overhead is unjustified.
    \item Language Barrier \\
        Choosing Flutter would prevent the sharing of DTOs and validation logic (TypeScript) between backend and frontend.
\end{itemize}

\subsubsection{React vs. Angular}
Angular is a comprehensive enterprise framework, but React was preferred for:
\begin{itemize}
    \item Flexibility vs. Rigidity \\
        For a relatively simple application, Angular's complexity introduces unnecessary boilerplate.
    \item Mobile Path \\
        React Native offers a significantly better performance and "native feel" than Angular's primary mobile path (Ionic/WebView).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project Structure}
The project will follow a Monorepo structure (using pnpm workspaces) to facilitate code sharing and consistent tooling.

\begin{verbatim}
/
  /apps
    /backend      # Node.js Express API
    /frontend     # React application
  /packages
    /shared       # Shared Zod schemas, TypeScript types, and utilities
  /docker         # Docker configuration files
  docker-compose.yml
\end{verbatim}

\subsection{Frontend Internal Structure}
Within \texttt{apps/frontend/src}, the structure follows a feature-based organization:
\begin{verbatim}
/src
  /assets         # Static files (images, fonts)
  /components     # Shared UI components (Button, Input, Card)
  /features       # Domain-specific logic
    /auth         # Login, Register, Password Reset forms
    /gift-list    # List view, Item card, Claim logic
    /dashboard    # Celebrant admin panel
  /hooks          # Shared custom hooks (useAuth, useTheme)
  /lib            # Configuration (API client, utils)
  App.tsx         # Main entry point with Routing
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Mobile Strategy}
To prepare for the future mobile application, the frontend code will strictly separate \textbf{Business Logic} from \textbf{UI Components}.
\begin{itemize}
    \item Logic (Hooks) \\
        All API calls, state transformations, and validation rules will be encapsulated in Custom Hooks. These are UI-agnostic and can be reused in React Native.
    \item UI (Components) \\
        Visual components will be the only part requiring a rewrite (replacing HTML with React Native primitives).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation Details}
This section outlines the specific implementation strategies for key frontend components, routing, and user feedback mechanisms.

\subsection{Routing Strategy}
The application uses React Router (v7) to manage navigation. The routes are divided into Public (Guest) and Protected (Celebrant) areas.

\begin{itemize}
    \item Public Routes \\
    \begin{itemize}
        \item \texttt{/}: Landing page with Login/Register options for Celebrants.
        \item \texttt{/auth/forgot-password}: Form to request a password reset.
        \item \texttt{/auth/reset-password}: Form to set a new password using the token from the email.
        \item \texttt{/lists/:slug}: The main view for a Guest to see the gift list.
        \item \texttt{/lists/:slug/access}: A simple form to capture the Guest's email.
        \item \texttt{/lists/:slug/my-claims}: A filtered view showing only the items claimed by the current Guest.
    \end{itemize}
    \item Protected Routes (Celebrant Dashboard) \\
    Requires a valid JWT. Unauthenticated access redirects to \texttt{/}.
    \begin{itemize}
        \item \texttt{/dashboard}: Overview of all created lists.
        \item \texttt{/dashboard/new}: Form to create a new list.
        \item \texttt{/dashboard/:slug}: Management view for a specific list.
    \end{itemize}
\end{itemize}

\subsection{Component Architecture}
Key components will encapsulate specific business logic states to ensure a consistent user experience.

\subsubsection{Error Boundaries}
The application will implement React Error Boundaries at the feature level. This ensures that a failure in a specific component (e.g., a broken GiftCard) does not crash the entire application, allowing the user to continue using other parts of the system or simply refresh the affected section.

\subsubsection{GiftCard Component}
This is the core component for displaying a gift item. It has distinct visual states based on the item's status and the user's role.
\begin{itemize}
    \item Available State \\
        Displays the item details and a prominent "Claim" button.
    \item Claimed by Current User \\
        Visually distinct. Displays an "Unclaim" button.
    \item Claimed by Other \\
        The item appears "disabled" or transparent.
\end{itemize}

\subsubsection{ClaimButton Component}
Handles the interaction with the backend API.
\begin{itemize}
    \item Optimistic UI \\
        When clicked, the button immediately reflects the new state before the API response is received.
    \item Error Handling \\
        If the API call fails, the button reverts to its original state and triggers a global notification.
\end{itemize}

\subsection{Global Styling Strategy}
To maintain consistency, a set of CSS variables will be defined at the \texttt{:root} level.

\begin{itemize}
    \item Colors (The "Elegant Indigo" Palette) \\
    \begin{itemize}
        \item \texttt{--color-primary}: \texttt{\#6366f1}, \texttt{--color-secondary}: \texttt{\#f43f5e}, \texttt{--color-bg}: \texttt{\#f8fafc}.
    \end{itemize}
    \item Spacing \\
        Standardized scale: 4px, 8px, 16px, 24px, 32px.
    \item Typography \\
        \texttt{'Inter', system-ui, sans-serif}.
\end{itemize}

\subsection{Feedback Mechanisms}
The application will use the following mechanisms to ensure a smooth and informative user experience:
\begin{itemize}
    \item \textbf{Toasts}: Non-intrusive notifications for success (e.g., "Item claimed!") and errors.
    \item \textbf{Skeleton Loading}: Used during initial data fetching to prevent layout shifts and provide a sense of progress.
    \item \textbf{Empty States}: Custom informative messages or "Call-to-Action" (CTA) buttons when a view has no data.
    \begin{itemize}
        \item \textit{Dashboard}: If a Celebrant has no lists, a prominent "Create your first list" CTA is displayed.
        \item \textit{Gift List}: If a list has no items, Guests see a friendly message indicating that the celebrant is still working on it.
        \item \textit{My Claims}: If a Guest has not claimed anything, they are encouraged to browse the list again.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing Strategy}
To ensure reliability, a multi-layered testing approach is adopted.

\begin{itemize}
    \item \textbf{Unit Testing (Vitest + React Testing Library)} \\
        Used for testing individual components and utility functions.
    \item \textbf{Integration Testing (Vitest)} \\
        Focuses on the interaction between multiple components and hooks (TanStack Query).
    \item \textbf{End-to-End (E2E) Testing (Playwright)} \\
        Simulates real user workflows for both Celebrants and Guests.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Guest Session Management}
Since guests do not have a traditional account, their identity is tracked via a secure session mechanism.

\begin{itemize}
    \item \textbf{Cookie-Based Identity} \\
        Upon providing an email, the backend issues a \texttt{guest\_session} cookie (\texttt{HttpOnly}, \texttt{Secure}, \texttt{SameSite=Lax}).
    \item \textbf{Persistence} \\
        The session is tied to the browser. If a guest returns to the same list from the same browser, they will automatically see their claimed items highlighted. If the cookie is expired, the guest simply needs to re-enter their email on the access page to restore their session.
\end{itemize}
