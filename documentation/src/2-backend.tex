\chapter{Backend}
The backend of the Gift List application is designed to be robust, scalable, and secure. Based on the requirements for real-time interactivity and concurrent access, we have selected a Node.js environment. Node.js is an excellent choice for this application due to its event-driven, non-blocking I/O model, which efficiently handles multiple simultaneous connectionsâ€”critical for when guests are viewing and claiming gifts at the same time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Technology Stack}
The proposed technology stack for the backend includes:
\begin{itemize}
    \item Runtime Environment \\
        Node.js v24 (last LTS to Febbruary 2026).
    \item Web Framework \\
        Express.js. A minimalist and flexible framework that allows for rapid API development.
    \item Database \\
        PostgreSQL. Selected for its reliability and support for ACID transactions, which are essential for preventing race conditions (e.g., double-claiming a gift).
    \item ORM \\
        Prisma. To provide type-safe database access and simplify schema management.
    \item Authentication \\
        JSON Web Tokens (JWT) for stateless authentication of Celebrants, complemented by a Refresh Token strategy to ensure a seamless user experience without compromising security.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Architecture}
The backend will follow the Model-View-Controller (MVC) architectural pattern to ensure a clean separation of concerns.

\begin{itemize}
    \item Models \\
        Represent the data structures and encapsulate the core business logic. In our stack, the Models are defined and managed via Prisma, which handles database interactions and ensures data integrity through its schema.
    \item Views \\
        In the context of a RESTful API, the View layer is responsible for formatting the data into standard JSON responses. It ensures that the client receives only the necessary information in a structured format.
    \item Controllers \\
        Act as the intermediary between Models and Views. They receive incoming HTTP requests, process user input, interact with the Models to perform operations, and select the appropriate View to return to the client.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Database Schema (Prisma)}
The following Prisma schema defines the source of truth for our data models and their relations.

\begin{verbatim}
// schema.prisma

enum ItemStatus {
  AVAILABLE
  CLAIMED
}

enum PreferenceLevel {
  LOW
  MEDIUM
  HIGH
}

model User {
  id                 String     @id @default(uuid())
  email              String     @unique
  password           String
  resetToken         String?    @unique
  resetTokenExpires  DateTime?
  refreshToken       String?    @unique // For long-lived sessions
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  lists              GiftList[]
}

model GiftList {
  id           String        @id @default(uuid())
  userId       String
  user         User          @relation(fields: [userId], references: [id])
  slug         String        @unique // Globally unique
  name         String
  items        GiftItem[]
  guestAccess  GuestAccess[]
  deletedAt    DateTime?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model GiftItem {
  id          String          @id @default(uuid())
  listId      String
  list        GiftList        @relation(fields: [listId], references: [id])
  name        String
  description String?
  url         String?
  status      ItemStatus      @default(AVAILABLE)
  preference  PreferenceLevel @default(MEDIUM)
  claim       GuestClaim?
  deletedAt   DateTime?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
}

model GuestAccess {
  id        String       @id @default(uuid())
  listId    String
  list      GiftList     @relation(fields: [listId], references: [id])
  email     String
  language  String       @default("en")
  claims    GuestClaim[]
  createdAt DateTime     @default(now())

  @@unique([listId, email])
}

model GuestClaim {
  itemId    String      @id
  item      GiftItem    @relation(fields: [itemId], references: [id])
  guestId   String
  guest     GuestAccess @relation(fields: [guestId], references: [id])
  createdAt DateTime    @default(now())
}
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configuration}
The application is configured using environment variables. These variables are essential for both development and production environments. It is recommended to create a \texttt{.env.example} file in the project root to serve as a template.

\begin{itemize}
    \item \texttt{DATABASE\_URL} \\
        The connection string for the PostgreSQL database, used by Prisma. \\
        Example: \texttt{postgresql://user:password@localhost:5432/giftlist}
    \item \texttt{JWT\_SECRET} \\
        A long, random, and secret string for signing and verifying JSON Web Tokens. This must be kept private.
    \item \texttt{PORT} \\
        The port for the Node.js server. Defaults to \texttt{3000} if not specified.
    \item \texttt{CORS\_ORIGIN} \\
        The URL of the frontend application allowed to access the API, to enforce Cross-Origin Resource Sharing (CORS) policies.
    \item \texttt{SMTP\_HOST}, \texttt{SMTP\_PORT}, \texttt{SMTP\_USER}, \texttt{SMTP\_PASS} \\
        Credentials for the SMTP server (used by Nodemailer) to send email notifications.
\end{itemize}

\subsection{Authentication Strategy: Access \& Refresh Tokens}
To balance security and usability, the application implements a dual-token system:
\begin{itemize}
    \item \textbf{Access Token (JWT)}: Short-lived (15 minutes). Sent in the \texttt{Authorization} header.
    \item \textbf{Refresh Token}: Long-lived (7 days). Stored in a \texttt{HttpOnly}, \texttt{Secure} cookie.
\end{itemize}
When the Access Token expires, the frontend automatically calls a \texttt{POST /auth/refresh} endpoint, which verifies the Refresh Token and issues a new Access Token. This ensures that the Celebrant stays logged in while they are actively using the dashboard.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Model}
The database schema is designed to support the relationships between Celebrants, Lists, and Guests.
\begin{itemize}
    \item User (Celebrant): Stores celebrant data.
        \begin{itemize}
            \item \texttt{id}: UUID, Primary Key
            \item \texttt{email}: String, unique, required
            \item \texttt{password}: String, hashed, required
            \item \texttt{resetToken}: String, optional, unique (for password recovery)
            \item \texttt{resetTokenExpires}: Timestamp, optional
            \item \texttt{createdAt}: Timestamp, default: now
            \item \texttt{updatedAt}: Timestamp, auto-update
        \end{itemize}
    \item GiftList: Represents a specific event's wish list.
        \begin{itemize}
            \item \texttt{id}: UUID, Primary Key
            \item \texttt{userId}: Foreign Key to User
            \item \texttt{slug}: String, unique. Automatically generated from the name.
            \item \texttt{name}: String, required
            \item \texttt{deletedAt}: Timestamp, optional (Soft delete)
            \item \texttt{createdAt}: Timestamp, default: now
            \item \texttt{updatedAt}: Timestamp, auto-update
        \end{itemize}
    \item GiftItem: Represents an individual gift.
        \begin{itemize}
            \item \texttt{id}: UUID, Primary Key
            \item \texttt{listId}: Foreign Key to GiftList
            \item \texttt{name}: String, required
            \item \texttt{description}: Text, optional
            \item \texttt{url}: String, optional
            \item \texttt{status}: Enum (\texttt{AVAILABLE}, \texttt{CLAIMED}), required, default: \texttt{AVAILABLE}
            \item \texttt{preference}: Enum (\texttt{LOW}, \texttt{MEDIUM}, \texttt{HIGH}), required, default: \texttt{MEDIUM}
            \item \texttt{deletedAt}: Timestamp, optional (Soft delete)
            \item \texttt{createdAt}: Timestamp, default: now
            \item \texttt{updatedAt}: Timestamp, auto-update
        \end{itemize}
    \item GuestAccess: Links a guest's email to a specific list for notification purposes.
        \begin{itemize}
            \item \texttt{id}: UUID, Primary Key
            \item \texttt{listId}: Foreign Key to GiftList
            \item \texttt{email}: String, required
            \item \texttt{language}: String (e.g., 'en', 'it'), required. Used for notification emails.
            \item \texttt{createdAt}: Timestamp, default: now
            \item A unique constraint should be on \texttt{(listId, email)}.
        \end{itemize}
    \item GuestClaim: A record linking a \texttt{GiftItem} to a \texttt{GuestAccess} record.
        \begin{itemize}
            \item \texttt{itemId}: Foreign Key to GiftItem, Primary Key (ensures an item is claimed only once)
            \item \texttt{guestId}: Foreign Key to GuestAccess
            \item \texttt{createdAt}: Timestamp, default: now
        \end{itemize}
\end{itemize}

\subsection{Deletion Strategy and Data Retention}
The application balances the need for data recovery with privacy and resource optimization through a two-tier deletion strategy.

\subsubsection{Soft Deletes}
To ensure data integrity and preserve history during active usage, the application adopts a soft-delete strategy for records manually removed by users (Celebrants). Instead of physically removing records, a \texttt{deletedAt} timestamp is set. API queries exclude these records by default.

\subsubsection{Automatic Expiration (Hard Delete)}
To prevent the database from growing indefinitely and to comply with data protection principles, an automatic cleanup process is implemented:
\begin{itemize}
    \item \textbf{Inactive Lists}: Any \texttt{GiftList} that has not been updated for more than 6 months (based on \texttt{updatedAt}) is considered expired. These lists, along with all their associated \texttt{GiftItem}s, \texttt{GuestAccess} records, and \texttt{GuestClaim}s, are permanently removed from the database.
    \item \textbf{Guest Data}: When a list is deleted (manually or automatically), its associated \texttt{GuestAccess} records are removed. The system periodically identifies guest emails that are no longer associated with any active or soft-deleted list and purges them to ensure no unnecessary personal identifiable information (PII) is retained.
\end{itemize}

A scheduled background task (cron job) will execute these cleanup operations daily during low-traffic hours.

\subsection{Data Validation Rules}
To ensure data integrity and security, the following validation rules will be enforced at the API level.

\subsubsection{Shared Schemas}
To guarantee a Single Source of Truth (SSOT) between the Frontend and Backend, validation schemas are defined using \textbf{Zod} in a shared workspace package (\texttt{packages/shared}). The backend imports these schemas directly to validate incoming request bodies, ensuring that client-side validation logic matches server-side rules exactly.

\subsubsection{Entity Rules}
\begin{itemize}
    \item User (Celebrant)
    \begin{itemize}
        \item \texttt{email}: Must be a syntactically valid email address.
        \item \texttt{password}: Must be at least 8 characters long and contain at least one uppercase letter and at least one number or special character.
    \end{itemize}
    \item GiftList
    \begin{itemize}
        \item \texttt{name}: Must be between 3 and 50 characters long.
        \item \texttt{slug}: Must only contain lowercase letters, numbers, and hyphens (\texttt{-}).
    \end{itemize}
    \item GiftItem
    \begin{itemize}
        \item \texttt{name}: Must be between 3 and 50 characters long.
        \item \texttt{url}: If provided, must be a valid URL format.
        \item \texttt{description}: Optional. If provided, it must not exceed 200 characters.
    \end{itemize}
    \item GuestAccess
    \begin{itemize}
        \item \texttt{email}: Must be a syntactically valid email address.
    \end{itemize}
\end{itemize}

\subsection{Slug Generation and Collision Strategy}
Slugs are URL-friendly strings generated from the list name.
\begin{itemize}
    \item \textbf{Global Uniqueness}: Since lists are accessed via \texttt{/api/v1/lists/:slug}, every slug must be unique across the entire system.
    \item \textbf{Generation}: The system uses a standard slugify algorithm (removing special characters and replacing spaces with hyphens).
    \item \textbf{Collision Handling}: If a generated slug already exists, a 5-character random alphanumeric suffix is appended (e.g., \texttt{birthday-party} becomes \texttt{birthday-party-x7r2e}).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{API Design}
The backend will expose a RESTful API versioned under the \texttt{/api/v1} prefix.

\subsection{Architectural Choice}
The decision to use a RESTful architecture over alternatives like gRPC or GraphQL is based on several key factors:
\begin{itemize}
    \item Simplicity \\
        REST is the native standard of the web. It allows for straightforward integration with any browser-based client without the need for specialized libraries or complex client-side configurations.
    \item Low Friction for Guests \\
        Since the application relies on sharing public links, REST ensures that the initial list retrieval is fast and compatible with all web environments.
    \item Productivity \\
        RESTful APIs are easy to document, test, and debug using standard tools (e.g., browser dev tools, curl). Given the linear nature of our data (Lists and Items), the overhead of GraphQL's schema management or gRPC's binary serialization (Protobuf) would not provide significant benefits for this specific use case.
\end{itemize}

\subsection{Error Handling}
The API uses standard HTTP status codes to indicate the success or failure of a request. In case of an error, the response body will contain a JSON object with a consistent structure:
\begin{verbatim}
{
  "error": {
    "code": "ERROR_CODE_STRING",
    "message": "A human-readable description of the error."
  }
}
\end{verbatim}

\subsubsection{Detailed Error Codes}
The following specific error codes are used to provide granular feedback to the client:
\begin{itemize}
    \item \texttt{AUTH\_INVALID\_CREDENTIALS}: The email or password provided is incorrect.
    \item \texttt{AUTH\_EMAIL\_ALREADY\_EXISTS}: Attempted to register with an email that is already in use.
    \item \texttt{AUTH\_TOKEN\_EXPIRED}: The provided JWT or reset token has expired.
    \item \texttt{LIST\_NOT\_FOUND}: The requested list slug does not exist or has been deleted.
    \item \texttt{ITEM\_NOT\_FOUND}: The requested item ID does not exist in the specified list.
    \item \texttt{ITEM\_ALREADY\_CLAIMED}: Attempted to claim an item that is no longer \texttt{AVAILABLE}.
    \item \texttt{ITEM\_NOT\_CLAIMED\_BY\_YOU}: Attempted to unclaim an item that was claimed by a different guest.
    \item \texttt{VALIDATION\_ERROR}: The request payload failed schema validation (e.g., missing fields, invalid formats).
\end{itemize}

\subsubsection{Common Status Codes}
\begin{itemize}
    \item \texttt{400 Bad Request}: The request was malformed or failed validation.
    \item \texttt{401 Unauthorized}: Authentication is required and has failed.
    \item \texttt{403 Forbidden}: Permission denied for the requested action.
    \item \texttt{404 Not Found}: The resource could not be found.
    \item \texttt{409 Conflict}: Conflict with the current state (e.g., item already claimed).
    \item \texttt{500 Internal Server Error}: Unexpected server error.
\end{itemize}

\subsection{Authentication and Public Routes}
These routes handle celebrant authentication and guest operations. All routes are prefixed with \texttt{/api/v1}.
\begin{itemize}
    \item \texttt{POST /auth/register} \\
    Registers a new Celebrant account.
    \item \texttt{POST /auth/login} \\
    Authenticates a Celebrant and returns a JWT.
    \item \texttt{POST /auth/refresh} \\
    Exchanges a valid Refresh Token (from cookie) for a new Access Token.
    \item \texttt{POST /auth/forgot-password} \\
    Initiates the password reset process. Sends an email with a reset token if the email exists.
    \item \texttt{POST /auth/reset-password} \\
    Sets a new password using a valid reset token.
    \item \texttt{POST /lists/:slug/access} \\
    Registers or identifies a guest's email for a specific list. If the email already exists for this list, it refreshes the guest session.
    \textbf{Payload}: \texttt{\{ "email": "guest@example.com", "language": "it" \}}.
    The backend stores the email and sets a secure, \texttt{HttpOnly} session cookie.
    \item \texttt{GET /lists/:slug} \\
    Retrieves the gift list and all items. Requires a valid guest session. \textbf{Note:} For guests, this response includes the \texttt{status} of each item to show what is available.
    \item \texttt{GET /lists/:slug/my-claims} \\
    Retrieves only the items claimed by the current guest.
    \item \texttt{POST /items/:id/claim} \\
    Allows a guest to claim an item.
    \item \texttt{POST /items/:id/unclaim} \\
    Allows a guest to unclaim an item they previously claimed.
\end{itemize}

\subsection{Protected Routes (Celebrant Dashboard)}
These require a valid JWT in the Authorization header.
\begin{itemize}
    \item \texttt{GET /lists} \\
        Retrieves all lists created by the authenticated Celebrant.
    \item \texttt{POST /lists} \\
        Creates a new list. Requires a \texttt{name}.
    \item \texttt{GET /lists/:slug/manage} \\
        Retrieves the full details of a specific list for management. \textbf{Surprise Protection:} This route \textit{explicitly excludes} any information regarding the \texttt{status} (CLAIMED/AVAILABLE) or guest claims.
    \item \texttt{DELETE /lists/:id} \\
        Soft-removes an entire list. If items were claimed, notifications are triggered.
    \item \texttt{POST /lists/:id/item} \\
        Adds an item to a list.
    \item \texttt{PATCH /items/:id} \\
        Updates an item's details.
    \item \texttt{DELETE /items/:id} \\
        Soft-removes an item. Triggers a notification if the item was claimed.
\end{itemize}

\subsection{Slug Generation and Collision Strategy}
Slugs are URL-friendly strings generated from the list name.
To handle cases where multiple users choose the same name:
\begin{enumerate}
    \item The system generates the base slug.
    \item It checks for existence in the database.
    \item If a collision occurs, a short random alphanumeric suffix (e.g., \texttt{-x4k2}) is appended.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{API Specification (DTOs)}
To ensure consistency between frontend and backend, we define the following Data Transfer Objects.

\subsection{Authentication}
\begin{itemize}
    \item \textbf{Login Request}
\begin{verbatim}
{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
\end{verbatim}
    \item \textbf{Login Response (200 OK)}
\begin{verbatim}
{
  "token": "eyJhbG...",
  "user": {
    "id": "uuid-v4",
    "email": "user@example.com"
  }
}
\end{verbatim}
\end{itemize}

\subsection{Gift Lists}
\begin{itemize}
    \item \textbf{Get List Response (200 OK)}
\begin{verbatim}
{
  "id": "uuid-v4",
  "name": "Birthday 2026",
  "slug": "birthday-2026",
  "items": [
    {
      "id": "uuid-v4",
      "name": "Mechanical Keyboard",
      "description": "Blue switches preferred",
      "url": "https://amazon.com/...",
      "status": "AVAILABLE",
      "preference": "HIGH",
      "isClaimedByMe": false
    }
  ]
}
\end{verbatim}
    \item \textbf{Add Item Request}
\begin{verbatim}
{
  "name": "Lego Star Wars",
  "description": "The Millennium Falcon set",
  "url": "https://lego.com/...",
  "preference": "MEDIUM"
}
\end{verbatim}
    \item \textbf{Update Item Request (PATCH)}
\begin{verbatim}
{
  "name": "Updated Lego Set",
  "description": "Updated description",
  "url": "https://new-url.com",
  "preference": "HIGH"
}
\end{verbatim}
    \item \textbf{Guest Access Request}
\begin{verbatim}
{
  "email": "guest@example.com",
  "language": "it"
}
\end{verbatim}
\end{itemize}

\subsection{Error Response Example}
\begin{verbatim}
{
  "error": {
    "code": "ITEM_ALREADY_CLAIMED",
    "message": "This item has already been claimed by another guest."
  }
}
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Security}
\subsection{Rate Limiting}
To protect the application from brute-force attacks and DDoS, the following rate limits are applied:
\begin{itemize}
    \item \textbf{Auth Routes}: 5 requests per 15 minutes per IP.
    \item \textbf{Public Guest Access}: 20 requests per minute per IP.
    \item \textbf{General API}: 100 requests per minute per IP.
\end{itemize}

\subsection{CORS Policy}
The API will strictly enforce CORS, allowing requests only from the verified frontend domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Handling Concurrency}
To prevent the race condition when two guests from claiming the same item simultaneously, the backend will utilize database transactions. When a claim request is received:
\begin{enumerate}
    \item Start Transaction.
    \item Lock the specific Item row (e.g., \texttt{SELECT ... FOR UPDATE}).
    \item Verify the status is \texttt{AVAILABLE}.
    \item Insert a \texttt{GuestClaim} record and update Item status.
    \item Commit Transaction.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notification Service}
The notification service is designed to be resilient and non-blocking.
\begin{itemize}
    \item \textbf{Asynchronous Processing}: Notifications are handled asynchronously to prevent API latency. If an item is deleted, the system schedules the email task and immediately returns a success response to the user.
    \item \textbf{Reliability}: In case of SMTP failure, the system will attempt to retry the delivery up to 3 times with exponential backoff.
    \item \textbf{Privacy}: Guest emails are only used for required system notifications and are never shared or used for marketing.
\end{itemize}

If a Celebrant deletes an item that is already \texttt{CLAIMED}:
\begin{enumerate}
    \item The backend identifies the associated \texttt{GuestClaim}.
    \item The system schedules an email notification via the notification service.
    \item The item is then soft-deleted (\texttt{deletedAt} is set).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Email Templates}
To ensure a consistent and professional communication with users, the following email templates are defined. All emails will be sent in the user's preferred language (English or Italian).

\subsection{Item Removal Notification (Guest)}
Sent when a celebrant removes an item that the guest has already claimed.
\begin{itemize}
    \item \textbf{Subject (EN)}: Important update regarding your gift for [List Name]
    \item \textbf{Subject (IT)}: Aggiornamento importante sul tuo regalo per [List Name]
    \item \textbf{Body Content}:
        \begin{quote}
            Hi, \\
            We are writing to inform you that the item "[Item Name]" has been removed from the gift list "[List Name]" by the celebrant. \\
            If you have already purchased this gift, please be aware that it is no longer on their wish list. \\
            You can visit the list again to see if there are other items you would like to claim: [List URL].
        \end{quote}
\end{itemize}

\subsection{Password Reset (Celebrant)}
Sent when a celebrant requests a password recovery.
\begin{itemize}
    \item \textbf{Subject (EN)}: Password Reset Request for Gift List
    \item \textbf{Subject (IT)}: Richiesta di reset password per Gift List
    \item \textbf{Body Content}:
        \begin{quote}
            Hi, \\
            We received a request to reset the password for your account. Click the link below to set a new password. This link will expire in 15 minutes. \\
            \[Reset Link with Token\] \\
            If you did not request this, you can safely ignore this email.
        \end{quote}
\end{itemize}